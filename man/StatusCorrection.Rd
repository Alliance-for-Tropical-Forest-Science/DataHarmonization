% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/StatusCorrection.R
\name{StatusCorrection}
\alias{StatusCorrection}
\title{Status Correction}
\usage{
StatusCorrection(
  Data,
  DeathConfirmation = 2,
  UseSize = FALSE,
  AddRowsForForgottenCensuses = TRUE,
  KeepMeas = c("MaxHOM", "MaxDate")
)
}
\arguments{
\item{Data}{Dataset (data.frame or data.table)
The \emph{LifeStatus} column must be coded as:
- TRUE = alive,
- FALSE = dead,
- NA = unseen}

\item{DeathConfirmation}{Number of times (censuses) needed for an unseen tree
to be considered dead (numeric)  (Default = 2 censuses)}

\item{UseSize}{Use the size presence  (> min DBH) as a witness of the living status of the
tree (logical) (Default = FALSE)}

\item{AddRowsForForgottenCensuses}{TRUE: adds rows for forgotten censuses, FALSE: does not add any rows (logical).}

\item{KeepMeas}{In case of \strong{multiple diameter measurements} in the same
census year:
Possible values: "MaxHOM", "MaxDate" (character).
\itemize{
\item "MaxHOM": apply the correction to the measurement taken at the
\strong{highest POM}
\item "MaxDate": apply the correction to the \strong{most recent measurement} (same
year but more recent date)
}}
}
\value{
Fill the \emph{Comment_DataHarmonization} column with error type information and add
a \emph{LifeStatus_DataHarmonizationCor} column with corrected trees life status. If AddRowsForForgottenCensuses is TRUE, a column \emph{MissedStem_DataHarmonizationCor} is added with value TRUE for new rows.
}
\description{
Detect errors, or detect errors and correct, the tree life
status evolution over the censuses.
Inspired by the code of Nino Page package (ForestData::correct_alive() and
.correct_alive_tree())
}
\details{
\itemize{
\item if UseSize : if Diameter != NA -> Alive
If (the value in bold is modified by the value given after the arrow):
(the ">" gives the chronological order of the sequence)
\item \emph{Dead} > Alive -> NA
\item add rows for the forgotten censuses between 2 'Alive' if chosen
\item Alive > \emph{Dead}/\emph{NA} > Alive -> Alive
\item Alive > \emph{NA} > Dead -> NA
\item Alive > \emph{Dead} > NA -> Dead
\item Alive > \emph{NA} > \emph{NA}:
if DeathConfirmation > unseens -> NA
if DeathConfirmation =< unseens -> Dead
}
}
\examples{
library(data.table)
data(TestData)

selection <- c("101184", "101433","101435","101436")

# Write the sequence
TestData <- TestData[order(IdCensus)] # arrange IdCensus in ascending order
TestData[IdTree == "101184", LifeStatus := c(TRUE, TRUE, TRUE, TRUE, FALSE)]
TestData[IdTree == "101433", LifeStatus := c(FALSE, TRUE, TRUE, TRUE, TRUE)]
TestData[IdTree == "101435", LifeStatus := c(TRUE, TRUE, NA, FALSE, TRUE)]
TestData[IdTree == "101436", LifeStatus := c(TRUE, NA, NA, FALSE, NA)]


Rslt <- StatusCorrection(TestData[IdTree \%in\% selection])


StatusCorrectionPlot(Rslt)

}
